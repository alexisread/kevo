\ Kevo  (c) Antero Taivalsaari 1992\ ------------------------------------------------------------------------\ This is a more clever implementation of semaphore, which has a separate\ wait queue. When all resources are in use, the allocating process\ will be automatically queued and suspended (removed from the round-robin \ scheduler). Since a queue is used, the suspended processes will be \ reactivated in the correct FIFO order.\ This is a one-way semaphore (no lock in v (signal) operation).Prototypes CDDEFINED Concurrency not IF MKDIR Concurrency THENConcurrency CDREF Semaphore2Semaphore.clone -> Semaphore2Semaphore2 ADDS  VAR waitQueue  Prototypes.Collections.Queue2.new -> waitQueue\ Access operations  : wait	(  --  )	<|	( this is a critical region )	  available 0= 	  IF up @ waitQueue.enqueue 		 multitasking on		 up @ suspend 		 |> ( wait here ) <| 	  THEN	  available 1- -> available 	|> ;  : signal	(  --  )	<|	  waitQueue.count IF waitQueue.dequeue activate THEN 	  available 1+ -> available 	|> ;\ Creation operations  : new		( resources initially -- newSemaphore )	nip 1000000 swap new	waitQueue.new -> over.waitQueue ;	  : clone	(  -- clonedSemaphore )	clone	waitQueue.clone -> over.waitQueue ;ENDADDS;