/* Kevo -- a prototype-based object-oriented language *//* (c) Antero Taivalsaari 1991-1993 				  *//* Some parts (c) Antero Taivalsaari 1986-1988 		  *//* lists.h: Dynamically growing lists (needed in various places) *//*------------------------------------------------------------------------*//* List management *//*	LISTs are used in several places of Kevo as internal storage	structures. For instance, each CONTEXT contains multiple LISTs to 	refer to the members of a clone family and to the parent and child	families. Furthermore, the browser uses LISTs to contain the cell 	indexes when properties are cut, copied, and pasted from one object 	to another.		LISTs are basically similar to OBJECTs defined in 'memory.h'. 	In other words, a LIST is composed of a handle (known as LIST) 	and a store part (known as STORE). This two-level structure 	allows us to easily resize lists.		For simplicity, LISTs have been implemented as linear structures.	However, since cloning is a very frequent operation in the system,	and LISTs are used to keep track of clone families, we have implemented 	LISTs so that the logical and physical sizes of lists are maintained	separately. In other words, we do not have to resize the list structure	each time when a new item is added to it.	To support easy browsing of clone families, each list object is actually	an OOP object. In other words, each list contains two extra items in the 	beginning of the list: the '(=context)' operation and a reference to a	context 'dummyContext'. */typedef struct listStruct 	LIST; struct listStruct {	STORE*	mfa;		/* Pointer to the store part (memory field address) */	int	physicalSize;	/* Physical list size */	int logicalSize;	/* Logical list size */};LIST* 		createList();void 		deleteList();void		addToList();void		condAddToList();int			removeFromList();void		storeToList();void*		fetchFromList();int			findInList();void		emptyList();void		optimizeList();