/* Kevo -- a prototype-based object-oriented language *//* (c) Antero Taivalsaari 1991-1993 				  *//* Some parts (c) Antero Taivalsaari 1986-1988 		  *//* lists.c: Dynamically growing lists (needed in various places) */#include "global.h"/*--------------------------------------------------------------------------*//* List management operations *//* createList(): create a new empty list */LIST* createList(){  /* Allocate object */  LIST*  newList = (LIST*)mymalloc(sizeof(LIST));  STORE* newStore  = createStore(DATAOFFSET+1); /* OOP cells plus one data cell */ 	/* Set the fields needed for closure objects */	newList->mfa = newStore; 				/* Storage part for storing list data */	newList->logicalSize = 0;  				/* Initially list is empty */	newList->physicalSize = DATAOFFSET+1;	/* One slot is allocated, though */	/* Make the list a full-fledged OOP object by storing */	/* the appropriate values to the two first slots */	newStore->efa = (int*)oContext;	newStore->pfa = (int*)dummyContext;	return(newList);}/* deleteList(): delete an existing list */void deleteList(list)LIST* list;{	free((STORE*)list->mfa);	free(list);}/* for debugging :void printList(list)LIST* list;{  int* store = (int*)list->mfa;  int  i;  	printf("List: %d contents:\n\t", list);	for (i = DATAOFFSET; i < list->logicalSize+DATAOFFSET; i++) printf("%d ", store[i]);		printf("\n");}*//* addToList(): add a new value to a list */void addToList(list, value)LIST* list;void* value;{  int  index = list->logicalSize+DATAOFFSET; /* New items are added to the end */  int* store;	/* For safety, zero values cannot be stored */	if (value == 0) return;	/* Extend the list in chunks of four cells */	if (index >= list->physicalSize) {		list->mfa = (STORE*)myrealloc(list->mfa, (list->physicalSize+4)*CELL);		list->physicalSize += 4;	}		store = (int*)list->mfa;	store[index] = (int)value;	list->logicalSize++;	#ifdef DEBUG	printf("Adding %d.\n", value);	printList(list);#endif}/* condAddToList: conditionally add a new value to a list *//* (only if the value is not previously in the list) */void condAddToList(list, value)LIST* list;void* value;{	if (!findInList(list, value)) addToList(list, value);}/* Remove a value from a list. 	Return true if the value is found (and removed) in the list, false otherwise. */int removeFromList(list, value)LIST* list;void* value;{	int index = findInList(list, value);		if (index) {	  int* store = (int*)list->mfa;			index += DATAOFFSET;		/* Move the rest of the list downwards */		while(index < list->logicalSize+DATAOFFSET) {			store[index-1] = store[index];			index++;		}			list->logicalSize--;		/* Store zero to the last (now unused) position just in case */		store[list->logicalSize+DATAOFFSET] = 0;#ifdef DEBUG		printf("Removing %d.\n", value);		printList(list);#endif		return(TRUE);	}	else return(FALSE);}/* storeToList(): store a value to a list *//*void storeToList(list, index, value)LIST* list;int	  index;void* value;{  int* store = (int*)list->mfa;	index++;	Physical indexes begin from two, user indexes from one 		if (index >= DATAOFFSET && index < list->logicalSize+DATAOFFSET)		store[index] = (int)value;	else {		fprintf(confile, "== Integrity error detected (out of bounds in LIST store) ==\n");		reportIntegrityError();		ownLongJmp();	}} *//* fetchFromList(): fetch a value from a list */void* fetchFromList(list, index)LIST* list;int	  index;{  int*  store = (int*)list->mfa;	index++;	/* Physical indexes begin from two (DATAOFFSET), user indexes from one */		if (index >= DATAOFFSET && index < list->logicalSize+DATAOFFSET)		return((void*)store[index]);	else {		fprintf(confile, "== Integrity error detected (out of bounds in LIST fetch) ==\n");		reportIntegrityError();		ownLongJmp();	}}/* findInList(): check if a certain value can be found in a list */int findInList(list, value)LIST* list;void* value;{  int   limit  = list->logicalSize+DATAOFFSET;  int*  store = (int*)list->mfa;  int   i;  	for (i = DATAOFFSET; i < limit; i++) {		if (store[i] == (int)value) return(i-1);	}	return(0);}/* emptyList(): erase an existing list to zero */void emptyList(list)LIST* list;{	if (list->physicalSize != DATAOFFSET+1) {		list->mfa = (STORE*)myrealloc(list->mfa, (DATAOFFSET+1)*CELL);		list->physicalSize = DATAOFFSET+1;	}	list->logicalSize = 0;}/* optimizeList(): minimize the memory consumption of a list */void optimizeList(list)LIST* list;{	if (list->physicalSize > list->logicalSize+DATAOFFSET) {		list->mfa = (STORE*)myrealloc(list->mfa, (list->logicalSize+DATAOFFSET)*CELL);		list->physicalSize = list->logicalSize+DATAOFFSET;	}}