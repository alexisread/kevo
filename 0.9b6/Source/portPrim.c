/* Kevo -- a prototype-based object-oriented language *//* (c) Antero Taivalsaari 1991-1993 				  *//* Some parts (c) Antero Taivalsaari 1986-1988 		  *//* portPrim.c: Non-portable primitives				  *//*	This file contains Kevo primitives which are not portable	from one machine platform to another.	Correct machine platform can be selected in file 'port.h'.*/#include "global.h"#include "portGlobal.h"/*---------------------------------------------------------------------------*//* Host system specific primitives */ /* system	( str --  ) *//* send a string to the host system for execution */void pSystem(){#ifdef UNIX  (void)system((char*)popData());#endif  (void)popData();}/* bye		( -- ) *//* exit from Kevo to the host system */void pBye(){  fprintf(confile, "== Exiting Kevo ==\n");  ZeroScrap();  TEToScrap();  ExitToShell();}/*---------------------------------------------------------------------------*//* Timing primitives */ /* clock	(  -- clock ) *//* return the processor time used by the program */void pClock(){  pushData((int)TickCount());}/* The following two definitions implement a very useful timer loop *//* The loop contents will be executed (at least) for a certain amount *//* of milliseconds *//* (msecsDo)	( msecs -- ) *//* loop beginning: calculate time limit  *//* if given time is zero, skip the whole loop */void poTimerDo(){  int param = popData();  int time = param * 6 / 10;	/* Convert milliseconds to Mac clock ticks */  if (param == 0) ip += (int)*ip; /* Skip over the whole loop */  else {	 pushReturn((int*)(ip+(int)*ip)); /* Push loop exit address */     pushReturn((int*)(time+TickCount())); /* Push exit time */     pushReturn((int*)1);		  /* The indexing begins from 1 */     ip++;						  /* Skip over the jump offset */  }}/* (msecsLoop)	( -- ) *//* timing loop end: if current time is greater than limit, end loop *//* else increment index by one */void poTimerLoop(){  int  index = (int)topReturn;  int  limit = (int)secondReturn;  if (TickCount() < limit) {   /* If time is still below the limit */	topReturn=(int*)(index+1); /* Increment index */	ip += (int)*ip;		 /* and go back to the beginning of the loop */  }   else { 	nPopReturn(3);		/* Otherwise remove return stack effects */	ip++;			    /* and continue (skip the address) */  }}/* eventDelay	(  -- address ) *//* return the address of our event delay variable *//* Determines the pause until events will be checked again (in 1/60 secs) */void pEventDelay(){  pushData((int)&eventDelay);}/* eventSlice	(  -- address ) *//* return the address of our event slice variable *//* Determines how much other Mac tasks will receive time (in 1/60 secs) *//* when events are being checked */void pEventSlice(){  pushData((int)&eventSlice);}/*---------------------------------------------------------------------------*//* Memory primitives *//* room		(  -- memoryAvailable )/* return the amount of free memory */void pRoom(){	pushData(FreeMem());}/* lowMem	(  -- lowAddress )/* return the lowest location of the Kevo system *//* (beginning of the application heap) */void pLowMem(){	pushData((int)lowMemLimit);}/* highMem	(  -- highAddress )/* return the highest location of the Kevo system *//* (end of the application heap) */void pHighMem(){	pushData((int)highMemLimit);}/*---------------------------------------------------------------------------*//* Input/output primitives *//*  To allow multitasking, Kevo's input/output operations must  operate on a character at a time basis. In a mainframe environment,  this obviously consumes more processor time. However, note that all  I/O primitives call 'yield' so that within the Kevo system processor  execution time is not wasted in e.g. waiting for a next keypress  from the keyboard. Important: 'yield' can only be the last operation in  a primitive.*//* emit		( b -- ) *//* emit a single character to outfile */void pEmit(){  WindowPtr thisWindow;  TEHandle	thisTE;  char 		c = (char)popData();  	if (!outfile) {		/* If the task has no associated window, ignore printing */		thisWindow = (WindowPtr)(*up)->window;		if (!thisWindow) return;		if (thisTE = getWindowTE(thisWindow)) TEKey(c, thisTE); 		else {	/* window has no associated TE -> use QuickDraw */			GrafPtr savePort;			GetPort(&savePort);			SetPort(thisWindow);			DrawChar(c);			SetPort(savePort);		}	} 	else {	/* print to file */		fprintf(outfile, "%c", c);		/* fflush(outfile); */	}  	yield();}/* type		( addr -- ) *//* type a whole string to outfile */void pType(){  WindowPtr	thisWindow;  TEHandle 	thisTE;  char* 	str = (char*)popData();  int 		len = strlen(str);  	if (!outfile) {		/* If the task has no associated window, ignore printing */		thisWindow = (WindowPtr)(*up)->window;		if (!thisWindow) return;		if (thisTE = getWindowTE(thisWindow)) TEInsert(str, len, thisTE);		else {	/* window has no associated TE -> use QuickDraw */			GrafPtr savePort;			GetPort(&savePort);			SetPort(thisWindow);			DrawString(CtoPstr(strcpy(charbuffer, str)));			SetPort(savePort);		}	}	else {	/* print to file */ 		fprintf(outfile, "%s", str);  		fflush(outfile);		}		yield();}/* page     	( -- ) *//* Clear the screen or start new page */void pPage(){  WindowPtr	thisWindow;  TEHandle	thisTE;		if (!outfile) {		/* If the task has no associated window, ignore printing */		thisWindow = (WindowPtr)(*up)->window;		if (!thisWindow) return;		if (thisTE = getWindowTE(thisWindow)) {   			GrafPtr savePort;			GetPort(&savePort);			SetPort(thisWindow);  			TESetText("", 0, thisTE);			EraseRect(&(*thisTE)->viewRect); 			InvalRect(&(*thisTE)->viewRect); 			SetPort(savePort);		}		else { 	/* window has no associated TE -> use QuickDraw */			GrafPtr savePort;  			GetPort(&savePort);			SetPort(thisWindow);  			EraseRect(&(thisWindow->portRect)); 			/* InvalRect(&(thisWindow->portRect)); updates not implemented */			MoveTo(4, 16);			SetPort(savePort);		}  	}  	else fprintf(outfile, "\f");  	yield();}/* bell		(  -- ) *//* Sound the bell */void pBell(){	if (!outfile) SysBeep(1);	else fprintf(outfile, "\a");	yield();}/* cr		(  -- ) *//* print carriage return */void pCr(){  ownCr();  yield();}/* spaces	( n --  ) *//* print n spaces *//* xxx This is quite a stupid implementation */void pSpaces(){  int n = popData();  int i = 0;  for ( ; i < n; i++) charbuffer[i] = ' ';  charbuffer[n] = 0;  ownPrintf("%s", charbuffer);}/* .		( l -- ) *//* print the topmost data stack item to outfile as a signed integer */void pPrint(){  ownPrintf("%d ", popData());  yield();}/* u.		( l -- ) *//* print the topmost data stack item to outfile as an unsigned integer */void pUPrint(){  ownPrintf("%u ", (unsigned)popData());  yield();}/* h.		( l -- ) *//* print the topmost data stack item to outfile as a hex number *//* Before printing, do appropriate formatting to the number */void pHPrint(){  char* format;  int number = popData();  if (number > 0xffff) format = "%08x ";  else if (number > 0xff) format = "%04x ";  else format = "%02x ";  ownPrintf(format, number);  yield();}/* key?		( -- b ) *//* check if any key is currently being pressed without waiting for it *//* return the key or FALSE */void pQKey(){  int c;  (*up)->endOfFile = FALSE;  if (!infile) {  	c = getFromKeyBuffer(up);  }  else {	if ((c = fgetc(infile)) == EOF) {		c = 0;		(*up)->endOfFile = TRUE;		pPopInfile();	}  }  pushData(c);  yield();}/* textAvailable	(  -- address TRUE <OR> FALSE ) *//* Check if we have a command line available for the parser *//* Return the address of the command line or FALSE */void pTextAvailable(){  char c;  char* start;  char* target;		(*up)->endOfFile = FALSE;	if (infile) {		/*  Buffer must be erased because otherwise keypresses 			from the keyboard might scramble the contents of 			the key buffer during file loading 		*/		eraseKeyBuffer(up);				while(TRUE) {			if ((c = fgetc(infile)) == EOF) {				(*up)->endOfFile = TRUE;				pPopInfile();				break;			}			if (c == CR || c == LF) break;			putToKeyBuffer(up, c); 		}		putToKeyBuffer(up, 0);		putToKeyBuffer(up, 0);	    	target = (char*)((*up)->textBuffer->mfa);  		start = &(target[((*up)->textTail)]);		(*up)->textTail = (*up)->textHead;		pushData((int)start);				pushData(TRUE);	}	else {		int avail;		/* Check if there is a line available in the task-specific text buffer */		pushData(avail = (int)lineAvailable(up));		if (avail) pushData(TRUE);	}	yield();}/* eraseText	(  --  ) *//* Erase the text buffer of the currently executing task */void pEraseText(){	eraseKeyBuffer(up);}/*---------------------------------------------------------------------------*//* GUI window primitives *//* <buildWindow>	( name -- windowHandle ) *//* Build a new plain window (with no TE facilities) */void pBuildWindow(){  char* str = (char*)popData();  WindowPtr newWindow = buildWindow(CtoPstr(strcpy(charbuffer, str)));	if (newWindow) {		ShowWindow(newWindow);		pushData((int)newWindow);	}	else {		if (!supervisor) {			ownPrintf("-- Out of memory in allocating new window");			execute((*up)->errorVector);		}		ownLongJmp();	}	yield();}			/* <buildTEWindow>	( name -- windowHandle ) *//* Build a new window (with TE facilities) */void pBuildTEWindow(){  char* str = (char*)popData();  WindowPtr newWindow = buildTEWindow(CtoPstr(strcpy(charbuffer, str)));	if (newWindow) {		ShowWindow(newWindow);		pushData((int)newWindow);	}	else {		if (!supervisor) {			ownPrintf("-- Out of memory in allocating new window");			execute((*up)->errorVector);		}		ownLongJmp();	}	yield();}			/* <buildGRTask>	(  -- task ) */  /* Create a new foreground task by copying the current one *//* The task has an own window but no TextEdit facilities *//* This makes the window ideal for displaying graphics etc. *//* Task's operation is initialized to 'boot' but it is not activated */void pBuildGRTask(){  TASK** newTask = buildTask();  WindowPtr newWindow;  	/* Build a new window for the newly created task */	newWindow = buildWindow("\pKevo Task");	if (newWindow) {		ShowWindow(newWindow);    		(*newTask)->window = (int*)newWindow;	}	pushData((int)newTask);	yield();}/* <buildTETask>	(  -- task ) */  /* Create a new foreground task by copying the current one *//* The task has its own window with TE facilities *//* This makes it ideal for displaying text (and also graphics) *//* Task's operation is initialized to 'boot' but it is not activated */void pBuildTETask(){  TASK** newTask = buildTask();  WindowPtr newWindow;  	/* Build a new TextEdit window for the newly created task */	newWindow = buildTEWindow("\pKevo Task");	if (newWindow) {		(*newTask)->window = (int*)newWindow;		ShowWindow(newWindow);	}	pushData((int)newTask);	yield();}/* showWindow		( window --  ) *//* display a window *//* if it is the only window on the screen, it becomes active */void pShowWindow(){	ShowWindow((WindowPtr)popData());	yield();}/* hideWindow		( window --  ) *//* hide and deactivate a window */void pHideWindow(){	HideWindow((WindowPtr)popData());	yield();}/* selectWindow		( window --  ) *//* select and activate a window */void pSelectWindow(){	SelectWindow((WindowPtr)popData());	yield();}/* frontWindow		(  -- window ) *//* return the id of the frontmost (active) window */void pFrontWindow(){	pushData((int)FrontWindow());}/* nextWindow		( window -- window ) *//* return the id of the next window in the Mac window list */void pNextWindow(){	WindowPeek thisWindow = (WindowPeek)topData;	topData = (int)thisWindow->nextWindow;}/* setWindowTitle	( nameAddr window --  ) *//* Change the name of an existing window */void pSetWindowTitle(){  WindowPtr thisWindow = (WindowPtr)popData();  char* string	= (char*)popData();    	SetWTitle(thisWindow, CtoPstr(strcpy(charbuffer, string)));	yield();}/* getWindowTitle	( window -- nameAddr ) *//* Get the name of a window */void pGetWindowTitle(){  WindowPtr thisWindow = (WindowPtr)topData;	GetWTitle(thisWindow, (Str255*)charbuffer);	PtoCstr(charbuffer);	topData = (int)allocStrCpy(charbuffer);}/* setWindowSize	( xSize ySize window --  ) *//* Set the size of a window *//* taking into account window kind (TE, Browser, etc.) */void pSetWindowSize(){  WindowPtr thisWindow = (WindowPtr)popData();  short ySize = (short)popData();  short xSize = (short)popData();  GrafPtr savePort;	GetPort(&savePort);	SetPort(thisWindow);	SizeWindow(thisWindow, xSize, ySize, TRUE);	doResizeWindow(thisWindow, xSize, ySize);	DrawGrowIcon(thisWindow);	SetPort(savePort);	yield();}/* getWindowSize	( window -- xSize ySize ) *//* Get the current size of the window */void pGetWindowSize(){  WindowPtr thisWindow = (WindowPtr)popData();    	pushData((int)thisWindow->portRect.right);  	pushData((int)thisWindow->portRect.bottom);}/* setWindowLoc		( xLoc yLoc window --  ) *//* Move the window to the requested location (in global coord's) */void pSetWindowLoc(){  WindowPtr thisWindow = (WindowPtr)popData();  short yLoc = (short)popData();  short xLoc = (short)popData();	MoveWindow(thisWindow, xLoc, yLoc, FALSE);	yield();}/* getWindowLoc		( window -- xSize ySize ) *//* Get the current locations of the window (in global coord's) */void pGetWindowLoc(){  WindowPtr thisWindow = (WindowPtr)popData();  	pushData(0 - thisWindow->portBits.bounds.left);	pushData(0 - thisWindow->portBits.bounds.top);}/* getWindowKind	( window -- kind ) *//* Get the current size of a window */void pGetWindowKind(){  WindowPeek thisWindow = (WindowPeek)topData;    	topData = (int)thisWindow->windowKind;}/* TEDeactivate	( window --  ) *//* Deactivate the (possible) TextEdit in the given window *//* This operation can be used to avoid the text cursor *//* interfering with graphics drawing */void pTEDeactivate(){  WindowPtr thisWindow = (WindowPtr)popData();  TEHandle thisTE;  	thisTE = getWindowTE(thisWindow);	if (thisTE) TEDeactivate(thisTE);}/* TEActivate	( window --  ) *//* Activate the (possible) TextEdit in the given window */void pTEActivate(){  WindowPtr thisWindow = (WindowPtr)popData();  TEHandle thisTE;  	thisTE = getWindowTE(thisWindow);  	if (thisTE) TEActivate(thisTE);}/*---------------------------------------------------------------------------*//* GUI mouse & graphics primitives *//*    Note: all the graphics primitives below have been implemented so that they   affect only each task's own window on the screen. This is achieved by explicitly   changing the grafport before calling Mac QuickDraw routines.*//* getMouse 	(  -- x y ) *//* get mouse coordinates (in the task's own window coordinates) *//* Return (-1, -1) if the task has no associated window */void pGetMouse(){  Point pt;  GrafPtr savePort;  WindowPtr thisWindow = (WindowPtr)(*up)->window;  	if (!thisWindow) {		pushData(-1); pushData(-1); 		return;	}	GetPort(&savePort);	SetPort(thisWindow);  	  	GetMouse(&pt);  	pushData((int)pt.h);	pushData((int)pt.v);	SetPort(savePort);}/* button		(  -- flag ) *//* check if the mouse button is currently pressed in the current window */void pButton(){	if (!Button()) pushData(FALSE);  	else {   	  	WindowPtr thisWindow;		if ((thisWindow = (WindowPtr)(*up)->window) == FrontWindow()) {  			GrafPtr savePort;			Point pt;			GetPort(&savePort);			SetPort(thisWindow);  				GetMouse(&pt);				if (PtInRect(pt, &thisWindow->portRect)) pushData(TRUE);			else pushData(FALSE);			SetPort(savePort);		}				else pushData(FALSE);	}	yield();}/* setPort		( window --  ) *//* set the graf port */void pSetPort(){	SetPort((GrafPtr)popData());}/* getPort		(  -- window ) *//* get the current graf port */void pGetPort(){  GrafPtr port;    GetPort(&port);  pushData((int)port);}/* showPen		(  --  ) *//* Show pen */void pShowPen(){  GrafPtr savePort;  WindowPtr thisWindow = (WindowPtr)(*up)->window;  	if (!thisWindow) return;	GetPort(&savePort);	SetPort(thisWindow);  		ShowPen();	SetPort(savePort);}/* hidePen		(  --  ) *//* Hide pen */void pHidePen(){  GrafPtr savePort;  WindowPtr thisWindow = (WindowPtr)(*up)->window;  	if (!thisWindow) return;	GetPort(&savePort);	SetPort(thisWindow);  		HidePen();	SetPort(savePort);}/* getPen		(  -- x y ) */void pGetPen()/* Get pen location *//* If the task has no associated window, return (-1, -1) */{  GrafPtr savePort;  Point   pt;  WindowPtr thisWindow = (WindowPtr)(*up)->window;  	if (!thisWindow) {		pushData(-1); pushData(-1);		return;	}	GetPort(&savePort);	SetPort(thisWindow);  	  	GetPen(&pt);	pushData((int)pt.h);	pushData((int)pt.v);	SetPort(savePort);}/* setPenSize	( x y --  ) *//* Set pen size */void pSetPenSize(){  int y = popData();  int x = popData();  GrafPtr savePort;  WindowPtr thisWindow = (WindowPtr)(*up)->window;      if (!thisWindow) return;	GetPort(&savePort);	SetPort(thisWindow);  		PenSize(x, y);	SetPort(savePort);}/* setPenMode	( mode --  ) *//* Set pen mode (and, or, xor, bic, copy, ...) */void pSetPenMode(){  GrafPtr savePort;  WindowPtr thisWindow = (WindowPtr)(*up)->window;  	if (!thisWindow) {		(void)popData();		return;	}	GetPort(&savePort);	SetPort(thisWindow);  		PenMode((short)popData());	SetPort(savePort);}/* penNormalize	(  --  ) *//* Restore the initial characteristics of pen */void pPenNormalize(){  GrafPtr savePort;  WindowPtr thisWindow = (WindowPtr)(*up)->window;  	if (!thisWindow) return;	GetPort(&savePort);	SetPort(thisWindow);  		PenNormal();	SetPort(savePort);}/* moveTo	( x y --  ) *//* Move pen to a certain location */void pMoveTo(){  int y = popData();  int x = popData();  GrafPtr savePort;  WindowPtr thisWindow = (WindowPtr)(*up)->window;  	if (!thisWindow) return;	GetPort(&savePort);	SetPort(thisWindow);  		MoveTo(x, y);	SetPort(savePort);}/* moveDelta	( dx dy --  ) *//* Move pen relative to its current location */void pMoveDelta(){  int y = popData();  int x = popData();  GrafPtr savePort;  WindowPtr thisWindow = (WindowPtr)(*up)->window;  	if (!thisWindow) return;	GetPort(&savePort);	SetPort(thisWindow);  	  		Move(x, y);	SetPort(savePort);}/* lineTo		( x y --  ) *//* Draw a line from current pen location to a certain point */void pLineTo(){  int y = popData();  int x = popData();  GrafPtr savePort;  WindowPtr thisWindow = (WindowPtr)(*up)->window;  	if (!thisWindow) return;	GetPort(&savePort);	SetPort(thisWindow);  		LineTo(x, y);	SetPort(savePort);	yield();}/* lineDelta	( dx dy --  ) *//* Draw a line relative to pens current location */void pLineDelta(){  int y = popData();  int x = popData();  GrafPtr savePort;  WindowPtr thisWindow = (WindowPtr)(*up)->window;  	if (!thisWindow) return;	GetPort(&savePort);	SetPort(thisWindow);  		Line(x, y);	SetPort(savePort);	yield();}/* setTextFont	( fontNumber --  ) *//* Set text font */void pSetTextFont(){  GrafPtr savePort;  WindowPtr thisWindow = (WindowPtr)(*up)->window;  	if (!thisWindow) {		(void)popData();		return;	}	GetPort(&savePort);	SetPort(thisWindow);  	TextFont((short)popData()); 		SetPort(savePort);}	/* setTextFace	( fontFace --  ) *//* Set text face (normal, bold, underlined, ...) */void pSetTextFace(){  GrafPtr savePort;  WindowPtr thisWindow = (WindowPtr)(*up)->window;  	if (!thisWindow) {		(void)popData();		return;	}	GetPort(&savePort);	SetPort(thisWindow);  	TextFace((short)popData()); 		SetPort(savePort);}	/* setTextMode	( fontMode --  ) *//* set text mode (and, or, xor, bic, copy, ... ) */void pSetTextMode(){  GrafPtr savePort;  WindowPtr thisWindow = (WindowPtr)(*up)->window;  	if (!thisWindow) {		(void)popData();		return;	}	GetPort(&savePort);	SetPort(thisWindow);  	TextMode((short)popData()); 		SetPort(savePort);}	/* setTextSize	( fontSize --  ) *//* Set text font size */void pSetTextSize(){  GrafPtr savePort;  WindowPtr thisWindow = (WindowPtr)(*up)->window;  	if (!thisWindow) {		(void)popData();		return;	}	GetPort(&savePort);	SetPort(thisWindow);  	TextSize((short)popData()); 		SetPort(savePort);}	/* drawChar		( char --  ) *//* Draw a character as graphics */void pDrawChar(){  char c = (char)popData();  GrafPtr savePort;  WindowPtr thisWindow = (WindowPtr)(*up)->window;  	if (!thisWindow) return;	GetPort(&savePort);	SetPort(thisWindow);	DrawChar(c);	SetPort(savePort);	yield();}/* drawString		( stringAddr --  ) *//* Draw a string as graphics */void pDrawString(){  GrafPtr savePort;  WindowPtr thisWindow = (WindowPtr)(*up)->window;  	if (!thisWindow) {		(void)popData();		return;	}	GetPort(&savePort);	SetPort(thisWindow);  	DrawString(CtoPstr(strcpy(charbuffer, (char*)popData())));	SetPort(savePort);	yield();}/* wipeScreen	(  --  ) *//* wipe the graphics off the window */void pWipeScreen(){  GrafPtr savePort;  WindowPtr thisWindow = (WindowPtr)(*up)->window;  	if (!thisWindow) return;    	GetPort(&savePort);  	SetPort(thisWindow);  	  	EraseRect(&(thisWindow->portRect));   	InvalRect(&(thisWindow->portRect)); 	SetPort(savePort);	yield();}/*---------------------------------------------------------------------------*//* Browser primitives *//* browse		( object --  ) *//* open a browser for the given object */void pBrowse(){  OBJECT* object = (OBJECT*)popData();	/* 		Note: this operation is not intended for opening 		clone family browsers.	*/	if (isContextObject(object)) openBrowser(object, NIL, BrowserWKind);	yield();}/* unbrowse		( object --  ) *//* Delete the browser of the requested object if such a browser exists *//* This operation is intended to be used mainly internally by the user interface */void pUnbrowse(){  OBJECT* object = (OBJECT*)popData();  WindowPtr browserWindow = findBrowser(object);	if (browserWindow) deleteBrowser(browserWindow);	yield();}/* cfBrowse		( cloneFamilyObject --  ) *//* Open a browser for a clone family object *//* This operation is intended to be used internally by the user interface */void pCfBrowse(){  OBJECT* object = (OBJECT*)popData();	if (isContextObject(object)) openBrowser(object, NIL, CloneBrWKind);	yield();}  /*---------------------------------------------------------------------------*//* InitPortedPrims(): initialize the names of non-portable primitive operations */void initPortedPrims(){  /* Host system specific primitives */  addPair(rootContext, "system", 	createPrimitive(pSystem));  addPair(rootContext, "bye", 		createPrimitive(pBye));  /* Timing primitives */  addPair(rootContext, "clock", 	createPrimitive(pClock));  addPair(rootContext, "(msecsDo)",	createPrimitive(poTimerDo)); hide();  addPair(rootContext, "(msecsLoop)",createPrimitive(poTimerLoop)); hide();  addPair(rootContext, "eventDelay",createPrimitive(pEventDelay));  addPair(rootContext, "eventSlice",createPrimitive(pEventSlice));  /* Memory primitives */  addPair(rootContext, "room", 		createPrimitive(pRoom));  addPair(rootContext, "lowMem", 	createPrimitive(pLowMem));  addPair(rootContext, "highMem", 	createPrimitive(pHighMem));  /* Input/output primitives */  addPair(rootContext, "emit", 		createPrimitive(pEmit));  addPair(rootContext, "type", 		createPrimitive(pType));  addPair(rootContext, "page", 		createPrimitive(pPage));  addPair(rootContext, ".",			createPrimitive(pPrint));  addPair(rootContext, "u.",		createPrimitive(pUPrint));  addPair(rootContext, "h.",		createPrimitive(pHPrint));  addPair(rootContext, "bell", 		createPrimitive(pBell));  addPair(rootContext, "cr", 		createPrimitive(pCr));  addPair(rootContext, "spaces", 	createPrimitive(pSpaces));  addPair(rootContext, "key?", 		createPrimitive(pQKey));  addPair(rootContext, "textAvailable",createPrimitive(pTextAvailable));  addPair(rootContext, "eraseText",	createPrimitive(pEraseText));  /* GUI window primitives */  addPair(rootContext, "<buildTEWindow>",createPrimitive(pBuildTEWindow)); hide();  addPair(rootContext, "<buildWindow>",createPrimitive(pBuildWindow)); hide();  addPair(rootContext, "<buildGRTask>",createPrimitive(pBuildGRTask)); hide();  addPair(rootContext, "<buildTETask>",createPrimitive(pBuildTETask)); hide();  addPair(rootContext, "showWindow",createPrimitive(pShowWindow));  addPair(rootContext, "hideWindow",createPrimitive(pHideWindow));  addPair(rootContext, "selectWindow",createPrimitive(pSelectWindow));  addPair(rootContext, "frontWindow",createPrimitive(pFrontWindow));  addPair(rootContext, "nextWindow",createPrimitive(pNextWindow));  addPair(rootContext, "setWindowTitle",createPrimitive(pSetWindowTitle));  addPair(rootContext, "getWindowTitle",createPrimitive(pGetWindowTitle));  addPair(rootContext, "setWindowSize",createPrimitive(pSetWindowSize));  addPair(rootContext, "getWindowSize",createPrimitive(pGetWindowSize));  addPair(rootContext, "setWindowLoc", createPrimitive(pSetWindowLoc));  addPair(rootContext, "getWindowLoc", createPrimitive(pGetWindowLoc));  addPair(rootContext, "getWindowKind",createPrimitive(pGetWindowKind));  addPair(rootContext, "TEDeactivate",createPrimitive(pTEDeactivate));  addPair(rootContext, "TEActivate",createPrimitive(pTEActivate));    /* GUI mouse & graphics primitives */  addPair(rootContext, "getMouse", 	createPrimitive(pGetMouse));  addPair(rootContext, "button",	createPrimitive(pButton));  addPair(rootContext, "setPort", 	createPrimitive(pSetPort));  addPair(rootContext, "getPort",	createPrimitive(pGetPort));  addPair(rootContext, "hidePen",	createPrimitive(pHidePen));  addPair(rootContext, "showPen",	createPrimitive(pShowPen));  addPair(rootContext, "getPen",	createPrimitive(pGetPen));  addPair(rootContext, "setPenSize",createPrimitive(pSetPenSize));  addPair(rootContext, "setPenMode",createPrimitive(pSetPenMode));  addPair(rootContext, "penNormalize",createPrimitive(pPenNormalize));  addPair(rootContext, "moveTo",	createPrimitive(pMoveTo));  addPair(rootContext, "moveDelta",	createPrimitive(pMoveDelta));  addPair(rootContext, "lineTo",	createPrimitive(pLineTo));  addPair(rootContext, "lineDelta",	createPrimitive(pLineDelta));  addPair(rootContext, "setTextFont",createPrimitive(pSetTextFont));  addPair(rootContext, "setTextFace",createPrimitive(pSetTextFace));  addPair(rootContext, "setTextMode",createPrimitive(pSetTextMode));  addPair(rootContext, "setTextSize",createPrimitive(pSetTextSize));  addPair(rootContext, "drawChar",  createPrimitive(pDrawChar));  addPair(rootContext, "drawString",createPrimitive(pDrawString));  addPair(rootContext, "wipeScreen",createPrimitive(pWipeScreen));  /* Browser primitives */  addPair(rootContext, "browse",	createPrimitive(pBrowse));  addPair(rootContext, "unbrowse",	createPrimitive(pUnbrowse));  addPair(rootContext, "cfBrowse",	createPrimitive(pCfBrowse)); hide();  }				