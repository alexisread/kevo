/* Kevo -- a prototype-based object-oriented language *//* (c) Antero Taivalsaari 1991-1993 				  *//* Some parts (c) Antero Taivalsaari 1986-1988 		  *//* memory.h: Memory and object management structures and internals *//* Memory allocation internals */char* 	mymalloc();char*	mycalloc();char*	myrealloc();char*	allocStrCpy();/* Object structures and internals *//* 	Note that in Kevo files the term 'object' has two meanings:1)	The plain term 'object' usually refers to a structure which	is composed of a handle and a store. The struct 'OBJECT*' is thus	actually a pointer to a handle, rather than an object in the 	object-oriented sense. The handle structure is called OBJECT, and	the data part STORE.		OBJECT structures may be of two basic kinds:		- 'primitive' is a special kind of OBJECT whose size field is 0		  and which refers to an executable C function (no STORE part).	 	- 'closure' is an OBJECT which contains executable threaded code	 	  in its STORE part. The threaded code may be a real operation,	 	  or then e.g. be a variable and load some data to data	 	  stacks. The data are stored within the threaded code itself.	Since OBJECT is a two-level structure, the size of the STORE part	can be changed dynamically (primitives cannot be resized, though).	2)	In some places we speak of "object-oriented objects". This term refers	to a special kind of 'OBJECT' which refers to a 'CONTEXT' structure.	Context is a name space, i.e. a mapping from names (called PAIRs) to	OBJECTs. It serves as the implementation-level equivalent of truly	object-oriented objects.	Note that the self-reference in Kevo is a pointer to OBJECT. Not all	OBJECTs can however receive messages.*/ /* IMPORTANT: 'mfa should always be the first field in 'objectStruct'. *//* 	References such as '(*up)->priority' are based on the fact that the offset	to store parts is zero. */typedef struct objectStruct 	OBJECT; typedef struct storageStruct 	STORE;struct objectStruct {	STORE*	mfa;	/* Memory pointer (memory field address) */	int		sfa;	/* Object size (size field address) */};/* Inlined for speed */#define		createStore(size)	((STORE*)mycalloc(1, (size)*CELL))OBJECT*		createPrimitive();OBJECT*		createClosure();OBJECT*		copyObject();void		deleteObject();void		resizeClosure();int			recognizeObject();/*   Store is a structure whose size may grow and shrink dynamically.  Primitive (C code) objects do not have a store field, but the address of  the C operation is stored directly in the 'mfa' field of the object.  The size field of a primitive object is always 0 to differentiate such  objects from other kinds of objects.*/struct  storageStruct {	int*	efa;	/* Execution field (execution field address) */	int*	pfa; 	/* Parameter field (parameter field address) */};