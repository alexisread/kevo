/* Kevo -- a prototype-based object-oriented language *//* (c) Antero Taivalsaari 1991-1993 				  *//* Some parts (c) Antero Taivalsaari 1986-1988 		  *//* files.c: file management internals 			  	  *//* 	Kevo supports very flexible Unix-like I/O redirection. 	Every task in the system can have its own input and output files.	Files operate in a stack-like manner, so that previous I/O	redirection will be stacked when a new file is opened.*//*	Note that these operations are actually not quite as simple as they look,	because files are task-specific and references to them are macros rather	than variables.*/#include "global.h"/* ----------------------------------------------------------------------- *//* initFiles(): initialize standard files *//* If file == 0, I/O is directed to a task-specific window.			*//* If file == stdout or confile, I/O is directed to console file.	*//* Otherwise I/O goes to the designated file.						*/void initFiles(){  infile = 0;  outfile = 0;  errfile = 0;  confile = stdout;}/* Push the current input file to the task-specific input file stack, *//* growing the size of the stack if needed, and redirect input to the *//* given file (which is assumed to be open). */void pushToIFS(file)FILE* file;{  int size;	if (infileSp >= (size = infileSSize)) {		/* Allocate space for two more files in the input file stack */		resizeClosure((*up)->infileStack, size+2);	}	infileStk[infileSp++] = (int)infile;  	infile = file;}/* Push the current input file to the task-specific file stack, and  *//* open a new file for reading instead (given a file name). */void pushInfile(fileName)char* fileName;{  FILE* file;	if ((file = fopen(fileName, "r")) == NIL) {		fprintf(confile, "== File error (cannot open for reading)."); showTaskID();		if (!supervisor) {			ownPrintf("-- Cannot open file '%s' for reading", fileName);			execute((*up)->errorVector);		}		ownLongJmp();  	}  	else pushToIFS(file);}  /* Close the current input file and return to the previous one. *//* Do not close 'stdin', though. */void popInfile(){	if (infileSp > 0) {  		FILE* file = infile;  		if (file && file != stdin) {   			if (fclose(file)) {  				fprintf(confile, "== File error (cannot close input)."); showTaskID();		   		if (!supervisor) {		   			ownPrintf("-- Cannot close input file");		   			execute((*up)->errorVector);				}				ownLongJmp();			}  		}		infile = (FILE*)(infileStk[--infileSp]);  	}}/* Push the current output file to the task-specific output file stack, *//* growing the size of the stack is needed, and redirect output to the *//* given file instead (which is assumed to be open) */void pushToOFS(file)FILE* file;{	int size;	if (outfileSp >= (size = outfileSSize)) {		/* Allocate space for two more files in the output file stack */		resizeClosure((*up)->outfileStack, size+2);	}	outfileStk[outfileSp++] = (int)outfile;  	outfile = file;}/* Push the current output file to the task-specific file stack, and  *//* open a new file for writing or appending instead (given a file name *//* and writing mode ("w" = write, "a" = append)) */void pushOutfile(fileName, mode)char* fileName;char* mode;{  FILE* file;  	if ((file = fopen(fileName, mode)) == NIL) {    	fprintf(confile, "== File error (cannot open for writing)."); showTaskID();		if (!supervisor) {			ownPrintf("-- Cannot open file '%s'", fileName);			execute((*up)->errorVector);		}		ownLongJmp();  	}  	else pushToOFS(file);}  /* Close the current output file and return to the previous one *//* Do not close stdout or stderr, though. */void popOutfile(){ 	if (outfileSp > 0) {  		FILE* file = outfile;		if (file && file != stdout && file != stderr) {  			if (fclose(file)) {				fprintf(confile, "== File error (cannot close output)."); showTaskID();	      		if (!supervisor) {	      			ownPrintf("-- Cannot close output file");	      			execute((*up)->errorVector);	      		}	      		ownLongJmp();	      	}		}		outfile = (FILE*)(outfileStk[--outfileSp]);	}}