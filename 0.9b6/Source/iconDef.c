/* Kevo Interactive Compiler kernel 			*//* (c) Antero Taivalsaari 1991-1992 			*//* Some parts (c) Antero Taivalsaari 1986-1988 	*//* iconDef.c: Definitions for icon-based browser*/#include "iconDef.h"/*---------------------------------------------------------------------------*//* Custom list definition procedure *//* This procedure replaces the standard list definition procedure contained *//* in the system file (LDEF resource 0). *//*	These definitions allow our browser to display the properties in browser 	windows as icons instead of mere text. The underlying representation of 	list cells has not been changed, and cells still contain the visibility 	info in the first position, and the object kind in the second position 	(e.g., ^M = public method). Indexed slots do not contain visibility info	at all, but the first bytes contain the index instead (e.g. <12>).*/pascal void main(lMessage, lSelect, lRect, lCell, lDataOffset, lDataLen, lHandle)short lMessage;Boolean lSelect;Rect lRect;Cell lCell;short lDataOffset;short lDataLen;ListHandle lHandle;{ 	Rect iconRect; 	DataHandle dataCells; 	char* thisData; 	char visibility; 	char objectKind; 	Handle thisIcon;	switch (lMessage) {		case lInitMsg:		case lCloseMsg:			/* Nothing has to be done when list manager is initialized or finalized */			break;		case lDrawMsg:		case lHiliteMsg: {			/* Icon selection: */			/* First, get the address of the data area */			dataCells = (*lHandle)->cells;			/* Get also the contents of the current cell using given offset */			thisData = *dataCells + lDataOffset;						/* The first character in the cell defines visibility */			visibility = *thisData;				/* The second character defines the kind of the object */			objectKind = *(thisData+1);						/* Choose the appropriate icon from resource file */			switch (visibility) {				case '^': /* The first character is '^' (public) */					switch (objectKind) {						case 'R': thisIcon = GetResource('ICN#', PUBLICREFICON); break;						case 'V': thisIcon = GetResource('ICN#', PUBLICVARICON); break;						case 'C': thisIcon = GetResource('ICN#', PUBLICCONSTICON); break;						case 'M': thisIcon = GetResource('ICN#', PUBLICMETHODICON); break;						case 'P': thisIcon = GetResource('ICN#', PUBLICPRIMICON); break;						default : thisIcon = 0; break;					}					break;									case '_':	/* The first character is '_' (hidden) */					switch (objectKind) {						case 'R': thisIcon = GetResource('ICN#', PRIVATEREFICON); break;						case 'V': thisIcon = GetResource('ICN#', PRIVATEVARICON); break;						case 'C': thisIcon = GetResource('ICN#', PRIVATECONSTICON); break;						case 'M': thisIcon = GetResource('ICN#', PRIVATEMETHODICON); break;						case 'P': thisIcon = GetResource('ICN#', PRIVATEPRIMICON); break;						default : thisIcon = 0; break;					}					break;								case '<': 	/* The first character is '<' (indexed slot) */					thisIcon = GetResource('ICN#', ARRAYICON); 					break;								default: 					thisIcon = 0;					break;			}  			/* Blank the whole cell before drawing anything */			EraseRect(&lRect);			/* If the list is uninitialized or empty, don't draw anything */			if (!thisIcon) return; 			/* Define a rectangle to which the icon will be drawn */ 			SetRect(&iconRect, lRect.left+1, lRect.top+1, lRect.left+33, lRect.top+33);  			/* Plot the icon */			PlotIcon(&iconRect, thisIcon);			/* Get the address of the data area again */			/* (resource loading may have moved memory) */			dataCells = (*lHandle)->cells;			thisData = *dataCells + lDataOffset;						/* Set the cursor for text drawing */			MoveTo(lRect.left + 20, lRect.top + 14);						/* Change text face */			/* If data is long and we are in multi-column mode, condense text */			if (lDataLen >= 20 && ((*lHandle)->dataBounds).right > 1) TextFace(condense);			else TextFace(normal);						/* Hidden property names are printed in italics */			if (visibility == '_') TextFace(italic);			/* Unless slot is indexed, skip the visibility and objectKind data */			if (visibility != '<') 				 DrawText(thisData, 3, lDataLen-3);			else DrawText(thisData, 0, lDataLen);			/* Cell is selected: invert the contents */			if (lSelect) InvertRect(&lRect);			break;		}	}}