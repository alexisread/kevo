/* Kevo -- a prototype-based object-oriented language *//* (c) Antero Taivalsaari 1991-1993 				  *//* Some parts (c) Antero Taivalsaari 1986-1988 		  *//* keybuf.c: Keyboard buffer operations 			  *//* 		These operations are suited mainly to event-driven systems, 	and thus may not be needed in all implementations of Kevo.*/#include "global.h"/*---------------------------------------------------------------------------*//* Keyboard buffer operations *//* Put one character to the task-specific text buffer */void putToKeyBuffer(thisTask, c)TASK**	thisTask;char 	c;{  char* target = (char*)((*thisTask)->textBuffer->mfa);  int head = (*thisTask)->textHead;  int size = (*thisTask)->textBuffer->sfa;	target[head++] = c;	/* Grow the text buffer if needed (allocate 32 bytes more) */	/* For safety, keep an extra blank cell in the end of the buffer */	if (head+CELL >= size*CELL) {		resizeClosure((*thisTask)->textBuffer, size+8);	}		((*thisTask)->textHead)++;}/* Put a string to the task-specific text buffer */void textToKeyBuffer(thisTask, string)TASK**	thisTask;char*	string;{	while (*string) putToKeyBuffer(thisTask, *string++);}/* Put two consecutive carriage returns to the text buffer.	This operation is needed frequently, since our parser needs two	separators between lines.*/void crsToKeyBuffer(thisTask)TASK** thisTask;{	putToKeyBuffer(thisTask, CR);	putToKeyBuffer(thisTask, CR);}/* Put a number (converted to text) to the task-specific text buffer */void numberToKeyBuffer(thisTask, number)TASK**	thisTask;int		number;{	sprintf(charbuffer, "%d", number);	textToKeyBuffer(thisTask, charbuffer);}	/* Get one character from the task-specific text buffer */char getFromKeyBuffer(thisTask)TASK** thisTask;{  char c;  char* target;   int head = (*thisTask)->textHead;  int tail = (*thisTask)->textTail;		if (tail == head) {		if (tail) eraseKeyBuffer(thisTask);		return (0);	}	target = (char*)((*thisTask)->textBuffer->mfa);	c = target[tail++];	((*thisTask)->textTail)++;	return(c);}/* Remove the latest character from the task-specific text buffer */void removeFromKeyBuffer(thisTask)TASK** thisTask;{  int head = (*thisTask)->textHead;  int tail = (*thisTask)->textTail;		if (tail == head) {		if (tail) eraseKeyBuffer(thisTask);		return;	}	((*thisTask)->textHead)--;}/* Erase the task-specific text buffer */void eraseKeyBuffer(thisTask)TASK** thisTask;{  int* target;  int i;	/* Initialize text pointers */	(*thisTask)->textHead = 0;	(*thisTask)->textTail = 0;	/* Resize the text buffer back to its original size (128 bytes) */	resizeClosure((*thisTask)->textBuffer, 32);	/* Blank the buffer with 128 zero bytes (32 CELLs) */	target = (int*)((*thisTask)->textBuffer->mfa);	for(i = 0; i < 32; i++) target[i] = 0;}/* 	Check if there is a command line available in the task-specific 	text buffer. Return address to the beginning of the command line.*/char* lineAvailable(thisTask)TASK** thisTask;{  char* target;  int head 	 = (*thisTask)->textHead;  int tail 	 = (*thisTask)->textTail;  int i = tail;  	if (tail == head) {		if (tail) eraseKeyBuffer(thisTask);		return (NIL);	}    target = (char*)((*thisTask)->textBuffer->mfa);	/* Find the first CR after 'tail' */  	while (target[i] != CR && i < head) i++;   	if (target[i] == CR) {		/* Use two zeros as line separators */  		target[i] = 0;  		target[i+1] = 0;  		(*thisTask)->textTail = i + 2;  		return(&(target[tail]));  	}  	else return(NIL);}