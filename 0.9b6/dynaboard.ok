\ Kevo  (c) Antero Taivalsaari 1992\ -----------------------------------------------------------------\ Dynaboard: Dynamically growing two-dimensional table for\ n x n noughts-and-crosses game\ The board is stored physically as a list of bytearrays\ (see files 'list.ok' and 'bytearray.ok')REF DynaboardObject.clone -> DynaboardDynaboard ADDS  VAR board  Prototypes.Collections.List.new -> board  Prototypes.Collections.ByteArray.new board.add    VAR leftEdge  VAR rightEdge  VAR topEdge  VAR bottomEdge\ Internal operations  : position	( x y -- physicalX physicalY )  	\ given a coordinate pair (x, y) in logical coordinates	\ return the physical indexes		swap leftEdge - 1+		swap topEdge  - 1+ ;   : fetchFromPos ( x y -- address )	\ given a coordinate pair, return the corresponding value		position board.fetch.fetch ; hidden  : storeToPos	 ( value x y --  )	\ given a coordinate pair, store to that position		position board.fetch.store ; hidden  : checkLimits		( x y -- true <or> x-inc y-inc false )  	\ check if the given coordinate pair is within the board	\ return true if it is, otherwise return false	\ and the number of columns and rows that must be added	\ to the board	{ -> TEMP y	  -> TEMP x	  		 TEMP xInc		 TEMP yInc			x CASE			leftEdge   < OF x leftEdge   - -> xInc ENDOF			rightEdge  > OF x rightEdge  - -> xInc ENDOF	    ENDCASE				y CASE			topEdge    < OF y topEdge    - -> yInc ENDOF			bottomEdge > OF y bottomEdge - -> yInc ENDOF	    ENDCASE	  	    xInc yInc or		IF   xInc yInc false		ELSE true		THEN 	} ; hidden  : withinBoard		( x y -- flag )  	\ check if the given coordinate pair is within the board	\ limits. Return true/false.	checkLimits	IF   true	ELSE 2drop false	THEN ;	  : addTopRows		( n --  )  	\ Add n new rows to the top of the board	\ initializing the newly allocated space to zeros	topEdge over - -> topEdge	TIMES		board.first.new 1 board.insert	LOOP ; hidden    : addBottomRows	( n --  )  	\ Add n new rows to the bottom of the board	\ initializing the newly allocated space to zeros	bottomEdge over + -> bottomEdge	TIMES		board.first.new board.add	LOOP ; hidden    : addLeftColumns	( n --  )  	\ Add n new columns to the left end of the board	\ initializing the newly allocated space to zeros	{ -> TEMP n		 TEMP source		 TEMP length			leftEdge n - -> leftEdge 		board.count TIMES			  i board.fetch.count    -> length			n i board.fetch.grow			1 i board.fetch.position -> source			source length source n + move			source n zero fill		LOOP	} ; hidden    : addRightColumns	( n --  )  	\ Add n new columns to the right end of the board	\ initializing the newly allocated space to zeros	{ -> TEMP n			rightEdge n + -> rightEdge		board.count TIMES			n i board.fetch.grow		LOOP	} ; hidden    	  : growBoard 	( xInc yInc --  )  	\ If xInc is negative, add -xInc columns to the left side of the board	\ If xInc is positive, add +xInc columns to the right side of the board	\ If yInc is negative, add -yInc rows to the top of the board	\ If yInc is positive, add +yInc rows to the top of the board	{ -> TEMP yInc	  -> TEMP xInc			xInc CASE			0> OF xInc     addRightColumns ENDOF			0< OF xInc +/- addLeftColumns  ENDOF		ENDCASE				yInc CASE			0> OF yInc     addBottomRows   ENDOF			0< OF yInc +/- addTopRows      ENDOF		ENDCASE	} ; 	    : ?growBoard	( x y --  )  	\ Grow the board if the given (x, y) position is outside of the board	checkLimits not IF growBoard THEN ; 	\ Access operations  : store	( char x y --  )  	\ store the requested char to the position (x, y)	\ growing the table if needed or possibly replacing the previous value	2dup ?growBoard storeToPos ;		  : fetch 	( x y -- value )  	\ fetch the value from the position (x, y) or zero if not within board	2dup withinBoard 	IF   fetchFromPos	ELSE 2drop 0	THEN ;   : put		( char x y -- flag ) 	\ put the requested char to the position (x, y)	\ but only if that position is not already in use	\ return flag telling if the addition was done	2dup fetch 	IF   2drop drop false	ELSE store true	THEN ;		  : initialize	(  --  )  	\ initialize the board back to its initial setting	BEGIN		board.count 1 >	WHILE		board.last dup board.remove		top.dispose	REPEAT	0 board.first.resize	0 -> leftEdge	0 -> rightEdge	0 -> topEdge	0 -> bottomEdge ;    \ Printing operations  : printContents  	board.count TIMES		i board.fetch.count TIMES			i j board.fetch.fetch ?dup 			IF   emit 			ELSE space 			THEN		LOOP cr	LOOP ;\ Creation operations  : new  	clone 	board.new -> over.board	board.first over.board.add	0 -> over.leftEdge	0 -> over.rightEdge	0 -> over.topEdge	0 -> over.bottomEdge ;	  : clone  	deepCopy ;  : dispose	board.count TIMES		i board.fetch.dispose	LOOP  	board.dispose	dispose ;ENDADDS;