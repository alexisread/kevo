\ Kevo  (c) Antero Taivalsaari 1992\ ------------------------------------------------------------------------\ SortList: List with sorting facilities\ The sorting facility has been implemented in a generic form\ so that it can be cut-copy-pasted to e.g. sets without\ any modifications. To ensure genericity, all the references\ to the actual data items are late-bound via the self-reference\ The required operations for the collection are:\ 	self.count 			should give the logical size of the collection\ 	i self.fetch 		should return the i'th item\ 	value i self.store  should store 'value' to i'th positionPrototypes CDDEFINED Collections not IF MKDIR Collections THENCollections CDREF SortListList.clone -> SortListSortList ADDS  VAR wStack  Prototypes.Collections.Stack.new -> wStack\ Internal operations  : compareCells		( index1 index2 -- <0/0/>0 )	{ self.fetch -> TEMP index2	  self.fetch -> TEMP index1		index1 hasContext		index2 hasContext and		IF   index1 index2.compare		ELSE index1 index2 -		THEN 	} ; hidden  : swapCells		( index1 index2 --  )	{ -> TEMP index2	  -> TEMP index1			 index1 self.fetch index2 self.fetch		 index1 self.store index2 self.store 	} ; hidden	    : partition	( min max -- p )	{ -> TEMP p	  dup -> TEMP m	      -> TEMP k		BEGIN			BEGIN				k 1+ -> k				k self.count <= 				IF k m compareCells 0< not				ELSE true				THEN 			UNTIL			BEGIN				p 1- -> p				p m compareCells 0> not			UNTIL			k p < IF k p swapCells THEN 			k p >= 		UNTIL		m p swapCells		p 	} ; hidden  : quickSort	( min max --  )  	\ QuickSort without the use of recursion	{ -> TEMP max	  -> TEMP min	     TEMP p			BEGIN			BEGIN				min max <			WHILE				min max 1+ partition -> p				p 2* max min - <				IF   max  wStack.push 					 p 1+ &.push					 p 1- -> max				ELSE p 1- wStack.push 					 min  &.push					 p 1+ -> min				THEN			REPEAT			wStack.isEmpty not		WHILE 			&.pop -> min 			&.pop -> max		REPEAT		wStack.erase 	} ;		\ Access operations  : sort	1 self.count quickSort ;	\ Creation operations  : new  	clone	wStack.new -> over.wStack ;   : clone  	clone	wStack.clone -> over.wStack ;  : dispose  	wStack.dispose	dispose ;ENDADDS;endFrom  : 3dup	( a b c -- a b c a b c )  	3 pick	3 pick	3 pick ; hidden  : quickSort2  	\ QuickSort without the use of recursion	\ This is an old version which uses stack manipulation	\ instead of temporary variables	BEGIN		BEGIN			2dup < 		WHILE			2dup 1+ partition			3dup 3dup 2* -rot swap - <			IF 	 swap wStack.push 1+ &.push 				 drop nip 1-			ELSE nip 1- wStack.push &.push				 1+ -rot nip			THEN		REPEAT 2drop		wStack.isEmpty not	WHILE		&.pop &.pop	REPEAT	wStack.erase ;			