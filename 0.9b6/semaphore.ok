\ Kevo  (c) Antero Taivalsaari 1992\ ------------------------------------------------------------------------\ This is a simple implementation of semaphore, which does not have\ a wait queue. When all resources are in use, the allocating process\ will be seized in a loop which automatically yields control to the\ next process. Since 'yield' is a very lightweight operation in Kevo, \ this does not cause much overhead.\ Note that this is a two-way implementation, which has locks in\ both p (wait) and v (signal) operations.Prototypes CDDEFINED Concurrency not IF MKDIR Concurrency THENConcurrency CDREF SemaphorePrototypes.Object.clone -> SemaphoreSemaphore ADDS  \ how many resources are available  VAR available  \ how many resources are there in total  VAR resources  1 -> resources\ Access operations  : wait	(  --  )	BEGIN 	  <| available 0=	WHILE 	  |>	REPEAT	available 1- -> available |> ;  : signal	(  --  )	BEGIN 	  <| available resources >= 	WHILE 	  |>	REPEAT	available 1+ -> available |> ;  : p	self.wait ;  : v	self.signal ;\ Printing operations  : printContents	available . ." of " resources . ." available" ;\ Creation operations  : new		( resources initially -- newSemaphore )	{ TEMP result		new -> result		0 max -> result.available		0 max -> result.resources 		result 	} ;ENDADDS;