\ Game of Life\ Invented by John Horton Conway, Cambridge University in the late 1960's\ -----------------------------------------------------------------------------\ Originally programmed for the FIFTH system \ (c) Antero Taivalsaari 7.4.1988\ Modified for Kevo 8.2.1992\ (c) Antero Taivalsaari 8.2.1992, 23.7.1992Applications CDDEFINED GameOfLife IF endFrom THENMKDIR GameOfLifeGameOfLife CDREF LifePrototypes.Object.clone -> LifeLife ADDS\ Constants and variables:  VAR max_x					hidden  VAR max_y					hidden  20 -> max_x				  10 -> max_y  VAR table1  VAR table2    Prototypes.Collections.ByteArray.new -> table1  Prototypes.Collections.ByteArray.new -> table2    max_x max_y * table1.resize  max_x max_y * table2.resize    VAR generation1  VAR generation2    table1 -> generation1  table2 -> generation2  VAR gen#			\ the number/age of current generation   VAR living#		\ number of living beings in the current society   ASCII * CONST "alive"		hidden     "bl" 	  CONST "dead"		hidden  2 CONST #preserve			hidden  3 CONST #birth			hidden\ Auxiliary printing operations:  : hBorder		ASCII - emit ; hidden  : vBorder		ASCII ! emit ; hidden  : corner		ASCII + emit ; hidden  : cornerRow	corner max_x 2+ TIMES hBorder LOOP corner ; hidden  : centerRow   vBorder max_x 2+ spaces vBorder ; hidden  : .line       ." ----------------------------------------------------------------" cr ; hidden\ The program:  : alive?      "alive" = ; hidden		( b -- f )  : >index		\ Convert a two-dimensional index to one-dimensional one  				1- max_x * + ; hidden	( x y -- index )  : newSociety	\ generate the first generation of a new society                \ given the initial percentage (probability) of living beings 				{ -> TEMP percentage	                0 -> gen#    	            table1 -> generation1        	        table2 -> generation2            	    cornerRow cr	                centerRow cr    	            0        	        max_y TIMES             	      vBorder space                 	  max_x TIMES                     	    1 100  rnd percentage <=	                        IF    "alive" i j >index generation1.store 1+    	                    	  "alive" emit        	                ELSE  "dead"  i j >index generation1.store            	            	  "dead"  emit                 	        THEN 	                  LOOP     	              space vBorder cr        	        LOOP -> living#            	    centerRow cr                	cornerRow cr       	         	." Generation: " gen# u.        	        ." Living: "	 living# u. 				} ;	hidden	( l --  )  : buddy?      >index generation1.fetch alive? IF 1+ THEN ; hidden		( n x y -- n )  : countBuddies \ calculate how many living friends a cell has				{ -> TEMP y				  -> TEMP x      	          0        	        x 1- y 1- buddy?            	    x 1- y    buddy?                	x 1- y 1+ buddy?	                x    y 1- buddy?    	            x    y 1+ buddy?        	        x 1+ y 1- buddy?            	    x 1+ y    buddy?                	x 1+ y 1+ buddy? 				} ;	hidden	( x y -- n )  : shouldBeAlive?	  				\ check if the cell should be alive in the next generation 				{ -> TEMP buddies			 	  -> TEMP currentAlive					buddies #preserve = 					currentAlive and					buddies #birth = or 				} ; hidden	( currentAlive? #ofBuddies -- flag )  : nextGeneration \ generate the next generation                 gen# 1+ -> gen#                0                max_y TIMES                   max_x TIMES                         i j >index generation1.fetch alive? 						i j countBuddies shouldBeAlive?                        IF    "alive" i j >index generation2.store 1+                        ELSE  "dead"  i j >index generation2.store                         THEN                   LOOP                 LOOP -> living# ; hidden			( -- )  : swapGenerations \ swap the generations (new generation becomes old) 				generation1 				generation2 -> generation1				-> generation2 ; hidden				  : printNextGeneration \ generate and print the next generation                 page                cornerRow cr                centerRow cr                gen# 1+ -> gen#                0                max_y TIMES                   vBorder space                   max_x TIMES                         i j >index generation1.fetch alive? 						i j countBuddies shouldBeAlive?                        IF    "alive" i j >index generation2.store 1+                        	  "alive" emit                        ELSE  "dead"  i j >index generation2.store                        	  "dead"  emit                         THEN                   LOOP                   space vBorder cr                LOOP -> living#                 centerRow cr                cornerRow cr                ." Generation: " gen# u.                ." Living: " 	 living# u. 				100 msecs ( 1 second pause ) ; hidden	(  --  )\ User-level words:  : setSize     \ change the size of the table                 -> max_y -> max_x				max_x max_y * table1.resize				max_x max_y * table2.resize ;	( x y --  )  : society		\ randomly generate a new society given a percentage				page newSociety cr ;		( percentage -- )  : following   \ generate and print n following generations				TIMES printNextGeneration swapGenerations cr LOOP ; ( n --  )  : older       \ generate n following generations without printing them				TIMES nextGeneration swapGenerations LOOP ; 		( n --  )  : help          .line                 ." Game of Life" cr                ." Commands:" cr                ."   x y setSize : sets the size of the society" cr		 		."   n society   : builds a new society (n = percentage of living)" cr                ."   n following : prints n next generations" cr                ."   n older     : ages the society by n without printing" cr                ."   help        : shows this message" cr                .line ;\ Creation operations  : new			\ create a new initialized life game solver				{ share -> TEMP result					table1.new dup -> result.table1 -> result.generation1					table2.new dup -> result.table2 -> result.generation2					0 -> result.gen#					0 -> result.living# 					result 				} ;  : clone		\ duplicate an existing life game solver				{ share -> TEMP result					table1.clone dup -> result.table1 -> result.generation1					table2.clone dup -> result.table2 -> result.generation2					result 				} ;				ENDADDS;